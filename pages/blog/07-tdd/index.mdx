import Post from "../../../components/post";

export const meta = {
  title: "TDD",
  description: "자바스크립트 패턴과 테스트",
  date: "2021-05-04T11:15:00.0Z",
  readTime: 4,
};

export default ({ children }) => <Post meta={meta}>{children}</Post>;

<div style={{  marginTop: "4rem", fontFamily: "NotoSansKR-Thin, MalgunGothic", fontSize: '11pt', lineHeight: '22pt', letterSpacing: '.8px'}}>

# TDD

<br />

<h3 style={{ fontFamily: "SeoulNamsanL" }}>
  단위 테스트할 수 있는 코드를 작성하라
</h3>

단위 테스트를 할 수 있는 코드를 만들려면 프로그램을 단위별로 나누어 개발하라.

단위란 작은 인터페이스 와 단일 책임을 가진 모듈을 말한다. 다른 단위의 서비스를 사용해야 한다면 의존성 주입이라는 SOLID 한 친구에게 부탁하라.
받는 쪽 생성자 함수를 통해 서비스를 주고자 한다면, 단위 테스트 시 모형을 사용해 테스트할 대상코드를 하나의 단위로 좁힌다.

<hr />

**테스트 결과 자체를 기능명세로 보고 될 수 있도록 구체적으로 기술한다.**

<br />

**기본적 TDD의 절차**

- 실패하는 테스트를 작성한다. 본인이 무엇을 테스트하려고 하는지 확실해진다.

  - 코딩 전 테스트를 먼저 작성한다.
  - 에러조건을 먼저 테스트한다.
  - 복잡한것 보다 간단한것을 먼저 테스트한다.
  - 구체적으로 작성한다.
  - 테스트 마다 한가지만 확인한다.

- 테스트가 성공할만큼 코딩한다.
- 리팩토링 한다.

  - DRY 하게 유지한다.

- 실패하는 테스트에서는 해당 기능을 어떻게 구성할지 또, 어떤 것이 필요한지등의 명세를 작성한다.

<br />

# BDD

- 테스트 코드는 곧 명세가 된다.
- BDD(행위 주도 개발) ~는 이러해야 한다. 동작에 대해 그린다.
- 사용자 측면에서의 테스트 한다. ( 잘 작동하는지 등의 여부를 체크한다. )
  - 사용자는 해당 기능이 어떻게 실행되는지 신경쓰지 않는다. 그저 자신이 기대하는대로 작동하는 지를 고려한다.

<div className="blog-post">

```ts
import { render, screen } from "@testing-library/react";

/*
  testing library를 사용할 때, 테스트를 작동하는 기능 명세 위주로 작성하게 되면,
  해당 테스트에서 필요로 하는 기능이 보일 것이다. 
  그때 API를 참조하여 해당 기능을 사용하는 식의 사고를 갖자.
*/

// story를 사용자의 관점, 실제 어떻게 동작하는지에 대해 테스팅 한다.
// 상태가 어떻게 관리되고, prop이 어떻게 넘어가는지 등의 테스트는 enzyme를 사용하자.
describe("Comment", () => {
  test("It renders the comment and the author", () => {
    // Arrange the dat(in this case props)
    const props = { comment: "Test for TDD & BDD", author: "Henry" };
    // Act
    render(<Comment {...props} />);
    // Now we should be asserting
    // that we are actually rendering the comment and author
    // Assert
    expect(screen.getByText(props.comment)).toBeDefined();
    expect(screen.getByText(`- ${props.author}`)).toBeDefined();
  });
});
```

</div>

<br />

</div>
