import Post from "../../../components/post";

export const meta = {
  title: "Typescript",
  description: "타입스크립트",
  date: "2021-04-23T14:21:00.0Z",
  readTime: 4,
};

export default ({ children }) => <Post meta={meta}>{children}</Post>;

<div style={{  marginTop: "4rem", fontFamily: "NotoSansKR-Thin, MalgunGothic", fontSize: '11pt', lineHeight: '22pt', letterSpacing: '.8px'}}>

<br />

# Generic Function

<div className="blog-post">

```ts
function g1<T>(a: T): void {}
function g2<T, Q>(a: T, b: Q): void {}

const g3 = <T>(a: T): void => {};

// type-alias
type Type1Func<T> = (T) => void;
```

</div>

<br />

# Companinon Object Pattern

<div className="blog-post">

```ts
type Currency = {
  unit: "EUR" | "KOR" | "JPY" | "USD";
  value: number;
};

let Currency = {
  DEFAULT: "USD",
  from(value: number, unit = Currency.DEFAULT): Currency {
    return { unit, value };
  },
};
```

</div>

<br />

# Advanced Function Types

<div className="blog-post">

```ts
// let a = [1, true] //  (number | boolean)[];

// prettier-ignore
function tuple<
  T extends unknown[] // (meaning T is an array of any kind of type).
> (
  ...ts: T
  ): T {
  return ts;
}

let a = tuple(1, true); // [number, boolean];
```

</div>

<br />

# React with Type

**리액트 컴포넌트 에서 타입 정의**

```ts
// 이벤트 객체와 이벤트 처리 함수의 타입
import React from "react";
type EventObject<T = HTMLElement> = React.SyntheticEvent<T>;
type EventFunc<T = HTMLElement> = (e: EventObject<T>) => void;
```

<br />

# User-Defined Type Guards

<div className="blog-post">

```ts
function isString(a: unknown): a is string {
  // boolean occur error because of Scope
  return typeof a === "string";
}

function parseInput(input: string | number) {
  let formattedInput: string;
  if (isString(input)) {
    formattedInput = input.toUpperCase();
  }
}
```

</div>

<br />

# Conditional (Utility) Types

<div className="blog-post">

```ts
type A = number | string
type B = string

/* U에 없는 T */
Exclude<T, U>;
type C = Exclude<A, B> // number

/* U에 할당한 T */
Extract<T, U>
type C = Extract<A, B> // string

/* null과 undefined를 계산합니다.*/
NonNullable<T>
type I = {a?: number | null}
type J = NonNullable<I['a']> // number

/* 함수의 리턴 타입을 계산합니다. */
ReturnType<F>
type T3 = (a: number) => string
type T4 = ReturnType<T3> // string
```

</div>
</div>
