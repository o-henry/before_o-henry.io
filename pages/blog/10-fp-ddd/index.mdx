import Post from "../../../components/post";

export const meta = {
    title: "Domain Modeling Made Functional",
    description: "함수형 프로그래밍",
    date: "2022-08-23T21:41:00.0Z",
    readTime: 30,
};

export default ({ children }) => <Post meta={meta}>{children}</Post>;

<div style={{ marginTop: "4rem", fontFamily: "Recoleta, NotoSansKR-Thin, MalgunGothic", fontSize: '11pt', lineHeight: '22pt', letterSpacing: '.8px'}}>

    FP with DDD <sup><a href="#fn1" id="fnref1"> ¹ </a></sup> 타입과 함수를 통해서 도메인 모델을 구현하는 방법을 배운다.


    > 소프트웨어 개발을 입력(모듈 · 컴포넌트 · 요구 사항) 과 출력(프로그램 · 최종 결과)이 있는 파이프라인 이라 생각하자.


    # Understanding the Domain
    도메인 전문가와 대화를 통해 도메인에 대한 설명을 접하게 된다. 이러한 논의를 통해 비즈니스를 이해하고 유비쿼터스 언어를 구축한다.
    * 거대한 도메인을 독립적으로 구현하고 진화할 수 있는 작은 컴포넌트로 분해해야 한다.
    * 도메인과 일치하는 코드구현을 목표로 하고 텍스트처럼 읽히고 개발자가 아닌 사람들이 이해할 수 있는 코드를 만들 수 있도록 해야한다.
    * 도메인 이외의 용어를 도입하는 것을 지양해야 한다.

    <br/>
    <br/>

    # Focus on business event
    기업은 데이터를 가지고 있을 뿐만 아니라 데이터를 어떻게든 변화시킨다.
    즉 일반적인 비즈니스 프로세스를 일련의 데이터 또는 문서 변환이라고 생각할 수 있다. 비즈니스의 가치는 이러한 변환 과정에서 창출되므로 이러한 변환이 어떻게 작동하고 서로 어떻게 관련되는지 이해하는 것이 매우 중요하다.
    <hr />
    그리고 이러한 구조를 파악하는데에 데이터 구조보다 <span className="high-light">도메인 이벤트</span>에 집중해야 한다.
    도메인 이벤트는 모델링 하려는 거의 모든 비즈니스 프로세스의 시작점이다. 이벤트를 도출하기 위해 이벤트 스토밍을 사용한다.

    <br />
    <br />

    # Event Storming
    DDD 접근 방식에서 도메인 이벤트를 발견하는 가장 적합한 방법은 이벤트 스토밍을 활용하는 것이다.
    혼자 이벤트 스토밍을 연습한다면 콘웨이의 법칙을 따라서 비즈니스에 필요한 팀 (배송 · 결제 등) 이라고 생각하며 요구사항을 고민해보자.
    도출한 이벤트는 타임라인으로 그룹화 할 수 있으며 이는 종종 한 팀의 출력이 다른 팀의 입력임을 분명히 한다.
    <br />
    <br />



    # Documenting Commands
    이벤트 스토밍을 통해 이벤트를 식별했다면 해당 이벤트를 촉발시키는 요청인 커맨드에 대해서 알아야 한다.
    커맨드는 물론 실패할 수 도 있지만 성공하면 해당 도메인 이벤트를 생성하는 워크플로우를 실행한다.

    * 만약 커맨드가 "T사에 주문 양식 보내기" 라면 워크플로우가 주문을 보낸 경우 해당 도메인 이벤트는 "주문 양식이 전송됨" 이 된다.
    * 명령 : 주문하기 · 도메인 이벤트 : 주문이 접수됨.

    책에서는 대부분의 비즈니스 프로세스를 이런 방식으로 모델링한다. 이벤트는 일부 비즈니스 워크플로우를 시작하는 명령을 트리거하고 워크플로우는 몇 가지 더 많은 이벤트를 출력한다. 물론 이러한 이벤트는 추가 커맨드를 트리거할 수 있다.

    <div className="think" style={{fontFamily: "Poppins"}}>
        커맨드와 도메인 이벤트는 서로 인풋이 될 수도 아웃풋이 될 수 도 있다. 커맨드에 의해서 이벤트가 트리거될 수 도 있고 이벤트에 의해서 커맨드가 트리거 될 수 도 있다.
    </div>

    <br />
    <br />

    # Partitioning the Domain to Subdomains
    기업이 이미 서비스별 부서를 갖고 있는 것처럼 도메인을 분리할 수 있다.
    > 도메인이라는 용어를 일관된 지식의 영역으로 정의하자.

    <br />
    <br />

    # Thinking About Inputs and Outputs
    위에서 구현한 도메인 에서 인풋과 아웃풋을 보다 확실히 구분하기 위해 "이 프로세스를 시작하기 위해서 어떠한 정보가 필요한가" 라는 질문을 던질 수 있다.
    워크플로우(시나리오)의 아웃풋은 항상 워크플로우가 생성하는 이벤트, 즉 다른 바운디드 컨텍스트에서 액션을 트리거하는 이벤트여야 한다.

    <br />
    <br />

    {/* # Documenting the Domain

    # Representing Complexity in Our Domain Model */}

    # A Functional Architecture
    좋은 아키텍처의 목표중 하나는 컨테이너 · 컴포넌트 · 모듈 사이의 다양한 경계를 정의하여 변화(새로운 요구사항)에 유연하고 비용을 최소화 하는 것이다.
    먼저 모놀리스 하게 시스템을 구축하고 이후에 필요시에 리팩토링하는 것이 좋다.

    <br />
    <br />

    # Communicating Between Bounded Contexts
    바운디드 컨텍스트 간에 커뮤니케이션은 이벤트를 통해 이뤄진다. 이벤트는 큐(Kafka · RabbitMQ)를 통해 전송할 수 있는데 모놀리식 함수형 프로그래밍 에서는 함수 호출을 통해서 업스트림 컴포넌트에서 다운스트림 컴포넌트로 이벤트를 전송할 수 있다.


    <br />
    <br />

    # Types are not classes
    A type is a just a name for a set of things. 도메인 모델을 타입을 통해서 표현할 수 있다.

    <div className="blog-post">
    ```ts
    1 data order_id
    2 // opaque -- don't care about representation
    3 data product_id
    4 // opaque -- don't care about representation
    5 data order_quantity is int
    6 // constrained to be between 1 and 100
    7 data phone_number is string
    8 // Must not be null or empty. Must only contain digits
    9 data order_line is order_id AND product_id AND order_quantity
    ```
    </div>

    도메인 개념을 사용한 표현을 타입을 통해 정의할 수 있다. 이는 일반 DDD에서 value-object를 표한하는 것과 유사하다. ADT를 활용하여 표현력을 높인다.

    <br />
    <br />


    # Fighting the impulse to do class-drvien design
    DDD의 핵심 원칙 중 하나는 persistence ignorance 다. 데이터베이스의 데이터 표현에 대해 걱정하지 않고 도메인을 정확하게 모델링하는 데 집중해야 하기 때문에 중요한 원칙이다.
    실제로 객체지향 역시 데이터베이스 모델에 치우치지 않는다. 의존성 주입 같은 기술은 데이터베이스 구현을 비즈니스 로직과 분리하도록 지원한다.
    그러나 도메인이 아닌 객체와 클래스의 관점에서 생각한다면 디자인에 편향을 도입하는 것에 조심해야 한다.
    <hr/>
    예를들어 도메인 전문가가 다양한 종류의 연락 메서드를 설명할때 아래처럼 클래스 계층을 구현하고 싶어질 수 있다.

    <div className="blog-post">
    ```ts
    1 // represents all kinds of contact methods
    2 class ContactMethodBase ...
    3
    4 // represents email contact method
    5 class EmailAddressContactMethod extends ContactMethodBase ...
    6
    7 // represents phone contact method
    8 class PhoneNumberContactMethod extends ContactMethodBase ...
    ```

    * 클래스가 실제세계에 존재하지 않는 인공적인 클래스를 도입한다.
    * 특정 클래스에 종속되어 있는 메서드는 재사용을 어렵게 한다.

    <div className="think">
        개인적으로 상속의 사용을 최대한 자제하는 상황에서 다른 예제를 사용하는게 맞지 않았을까
    </div>


    <br />

    # States and lifecycles
    대부분의 비즈니스 엔티티는 라이프사이클을 갖고 있다. 상태 및 라이프사이클 측면에서 생각해야한다.

    * 인보이스는 미지급 상태로 시작하여 지급 상태로 전환된다.
    * 구매자는 게스트로 시작한 다음 등록된 회원으로 전환된다.

    <br />
    <br />

</div>
<br />

    <hr style={{ border:".1px solid whiteSmoke" }} />

    <div style={{ height: "15px" }}></div>

    <ol>
        <li id="fn1" style={{ fontFamily: "Poppins" }} >
            Domain Modeling Made Functional - Scott Wlaschin <a href="#fnref1"></a>
        </li>
    </ol>

</div>
