import Post from "../../../components/post";

export const meta = {
  title: "Redux Saga",
  description: "리덕스 사가",
  date: "2021-05-30T14:02:00.0Z",
  readTime: 10,
};

export default ({ children }) => <Post meta={meta}>{children}</Post>;

<div style={{ marginTop: "4rem", fontFamily: "NotoSansKR-Thin, MalgunGothic", fontSize: '11pt', lineHeight: '22pt', letterSpacing: '.8px'}}>

프론트엔드를 크게 3가지로 나누어 보면,

**UI/UX로 이루어진 VIEW ・ 상태 관리 ・ API ・ CRUD 등의 사이드 이펙트 요소**들 로 나눌 수 있습니다.

<br />

**VIEW**

리액트에서 눈에 보이는 화면은 **one-way binding** 을 통해 이루어집니다.
뷰는 상태에 따른 값을 보여줍니다. 상태가 변하면 해당 부분만을 바꾸며 그저 보여주기만 합니다.

<br />

**상태 관리**

그럼 어떻게 뷰의 상태를 바꿀 수 있을까?

이를 위해서 리액트는 자체적으로 상태 관리를 위한 기능들을 제공해주고 있습니다.

기존 **state**는 얕은 상태관리 로직에 이점이 있지만, 앱이 거대해질 수록 컴포넌트 관리가 복잡해지면서 **prop-drilling** 등의 문제가 일어났습니다. 이를 해결하기 위해 **context**등의 새로운 기능이 추가 되었습니다.
하지만 **context**역시 특정 컴포넌트에 한정된다는 문제가 있었습니다.

<hr />

이러한 문제점을 해결하기 위해 나타난 라이브러리 / 패턴이 **redux** 입니다. **redux**는 **Flux** 패턴의
방식과 비슷 하게 개발된 상태 관리 도구 입니다. 모든 상태를 global한 store에 저장하여 어디서든
접근/사용 할 수 있게 함으로써, 개발자가 **상태관리와 ・ VIEW**에 대한 로직을 별개로 고민할
수 있게 했습니다.

<br />

**SIDE EFFECT**

개발자는 예측할 수 없는 상황을 싫어합니다.
간단한 예로 순수함수는 항상 같은 입력에는 같은 출력을 반환해야 하는데, 외부 요소에 의해 아웃풋이 변경된다거나 하는 등의 상황이 있습니다. 이러한 상황을 일으키는 걸 사이드 이펙트라고 합니다.
리액트에서는 사이드 이펙트를 처리하라고 `useEffect` 등의 함수를 사용하도록 하는데, 일반적으로 DB에 데이터를 저장한다거나 등의 일들을 위에서 처리합니다.

<br />

**redux-saga**

**redux-saga**는 위의 사이드이펙트를 전담하는 미들웨어 입니다.

**redux-saga**를 사용함으로써, **VIEW ・ 상태관리 ・ 사이드이펙트 관리** 를 모두 나누어서 관리할 수 있습니다.

<hr />

**saga의 작동원리**

UI 컴포넌트는 plain object action을 dispatch 함으로써 어떠한 일이 발생했다는 정보를 알립니다.
모든 것은 saga 내부에 캡슐화 되어야 합니다. 실제 task를 동작시키기 위해 `action(FETCH_REQUEST)` 을 **watch** 하는 **saga**를 만들어야 합니다.

<div className="blog-post">

```js
// UI components notify action to saga..
dispatch({
    type: 'FETCH_REQUEST',
    url: {}
    ...
})

// saga
import { take, fork, call, put } from "redux-saga/effects";

// The watcher: watch actions and coordinate worker tasks
function* watchFetchRequests() {
  while (true) {
    const action = yield take("FETCH_REQUEST");

    yield fork(fetchUrl, action.url);
  }
}

// The worker: perform the requested task
function* fetchUrl(url) {
  const data = yield call(fetch, url);

  yield put({
    type: "FETCH_SUCCESS",
    data,
  });
}
```

</div>

    take : 미들웨어에게 'FETCH_REQUEST' 라는 액션타입을 기다리라고 할때 사용합니다.
    미들웨어는 FETCH_REQUEST 액션이 전달 될 때까지 watchFetchRequests 제너레이터를 차단합니다.
    action이 매칭이 되면, 미들웨어는 제너레이터를 재실행 합니다.

    fork : 미들웨어에 action.url을 인수로 사용하여 새 fetchUrl 작업을 fork하도록 지시합니다.
    미들웨어는 fetchUrl 제너레이터를 watchFetchRequests 차단 없이 호출합니다.
    마치 병렬로 처리하는 것처럼 작동합니다.

    call : 미들웨어는 제너레이터가 Promise를 반환할때까지 일시정지합니다. 이후 제너레이터는 재시작합니다.

</div>

<br />

<hr
  style={{
    width: "15px",
    border: "0.325px solid gray",
    marginTop: "1.125rem",
    marginBottom: "1.125rem",
  }}
/>

##### 참조

[redux-saga](https://survivejs.com/blog/redux-saga-interview/)
