import Post from "../../../components/post";

export const meta = {
  title: "Redux Saga",
  description: "리덕스 사가",
  date: "2021-05-30T14:02:00.0Z",
  readTime: 10,
};

export default ({ children }) => <Post meta={meta}>{children}</Post>;

<div style={{ marginTop: "4rem", fontFamily: "Poppins, NotoSansKR-Thin, MalgunGothic", fontSize: '11pt', lineHeight: '22pt', letterSpacing: '.8px'}}>

프론트엔드를 크게 3가지로 나누어 보면,

**UI/UX로 이루어진 VIEW ・ 상태 관리 ・ API ・ CRUD 등의 사이드 이펙트 요소**들 로 나눌 수 있습니다.

<br />

**VIEW**

리액트에서 눈에 보이는 화면은 one-way binding 을 통해 이루어집니다.
뷰는 상태에 따른 값을 보여줍니다. 상태가 변하면 해당 부분만을 바꾸며 그저 보여주기만 합니다.

<br />

**상태 관리**

그럼 어떻게 뷰의 상태를 바꿀 수 있을까?

이를 위해서 리액트는 자체적으로 상태 관리를 위한 기능들을 제공해주고 있습니다.

기존 state는 얕은 상태관리 로직에 이점이 있지만, 앱이 거대해질 수록 컴포넌트 관리가 복잡해지면서 prop-drilling 등의 문제가 일어났습니다. 이를 해결하기 위해 context등의 새로운 기능이 추가 되었습니다.
하지만 context역시 특정 컴포넌트에 한정된다는 문제가 있었습니다.

<hr />

이러한 문제점을 해결하기 위해 나타난 라이브러리 / 패턴이 redux 입니다. redux는 Flux 패턴의
방식과 비슷 하게 개발된 상태 관리 도구 입니다. 모든 상태를 global한 store에 저장하여 어디서든
접근/사용 할 수 있게 함으로써, 개발자가 **상태관리와 ・ VIEW**에 대한 로직을 별개로 고민할
수 있게 했습니다.

<br />

**SIDE EFFECT**

개발자는 예측할 수 없는 상황을 싫어합니다.
간단한 예로 순수함수는 항상 같은 입력에는 같은 출력을 반환해야 하는데, 외부 요소에 의해 아웃풋이 변경된다거나 하는 등의 상황이 있습니다. 이러한 상황을 일으키는 걸 사이드 이펙트라고 합니다.
리액트에서는 사이드 이펙트를 처리하라고 `useEffect` 등의 함수를 사용하도록 하는데, 일반적으로 DB에 데이터를 저장한다거나 등의 일들을 위에서 처리합니다.

<br />

**redux-saga**

redux-saga는 위의 **사이드 이펙트**를 전담하는 미들웨어 입니다.

<hr />

**saga의 작동원리**

먼저, saga는 ES6의 Generator 를 사용합니다. Generator 는 `yield` 키워드 를 사용하는데, 해당 키워드를 만나면 동작을 멈추고, `next`가 와야 다음 동작으로 넘어갑니다.

<hr />

UI 컴포넌트는 action 을 dispatch 함으로써 어떠한 일이 발생했다는 정보를 알립니다.
모든 것은 saga 내부에 캡슐화 되어야 합니다. 실제 Task를 동작시키기 위해 `action(FETCH_REQUEST)` 을 **watch** 하는 saga를 만들어야 합니다.

<div className="blog-post">

```ts
// UI components notify action to saga..
// api 요청을 하게 되면, pending / resolve / reject 의 상태를 고려하여, 구성합니다.
dispatch({
    type: 'FETCH_REQUEST',
    url: {}
    ...
})

// saga
import { take, call, put } from "redux-saga/effects";

// The watcher: watch actions and coordinate worker tasks
function* watchFetchRequests() {
    // 'FETCH_REQEUST' 액션이 전달될때마다, fetchUrl 콜백함수를 실행 합니다.
    // saga middleware에서 해당 action을 계속 주시하고 있습니다 ...
    yield take("FETCH_REQUEST", fetchUrl);

    // or
    // const action = yield take('FETCH_REQUEST');
    // yield fork(fetchUrl, action.url);
}

// The worker: perform the requested task
function* fetchUrl(url): Generator {
  // call 함수의 Promise를 반환하는 함수(fetch)를 인자로하여,실행한 후 대기합니다.
  // resolve가 되면 generator 함수를 next 처럼 진행시킵니다.
  const data = yield call(fetch, url);

  // 비동기 요청이 끝나면, put을 통해 새로운 액션을 스토어에 전달합니다.
  yield put({
    type: "FETCH_SUCCESS",
    data,
  });
}
```

</div>

</div>

<br />

<hr
  style={{
    width: "15px",
    border: "0.325px solid gray",
    marginTop: "1.125rem",
    marginBottom: "1.125rem",
  }}
/>

##### 참조

[redux-saga](https://survivejs.com/blog/redux-saga-interview/)
