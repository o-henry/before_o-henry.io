import Post from "../../../components/post";

export const meta = {
  title: "Functional Programming",
  description: "함수형 프로그래밍",
  date: "2021-04-16T14:45:00.0Z",
  readTime: 10,
};

export default ({ children }) => <Post meta={meta}>{children}</Post>;

<div style={{ textAlign: "center", fontFamily: "Rajdhani" }}>
  Functional-Light-JS - Kyle Simpson
</div>

<div style={{ marginTop: "4rem", fontFamily: "Poppins", fontSize: '11pt', lineHeight: '22pt', letterSpacing: '.8px'}}>

# Pure Function and Array

<hr />

순수함수는 **side effect** 가 없는 함수를 말합니다.

- 함수 몸통에 입출력 관련 코드가 없어야 한다.
- 함수 몸통에서 매개변숫값을 변경시키지 않는다(매개변수는 const 나 readonly 형태로만 사용한다)
- 함수는 몸통에서 만들어진 결과를 즉시 반환한다.
- 함수 내부에 전역 변수나 정적 변수를 사용하지 않는다.
- 함수가 예외를 발생시키지 않는다.
- 함수가 콜백 함수로 구현되어 있거나, 함수 몸통에 콜백 함수를 사용하는 코드가 없다.
- 함수 몸통에 Promise와 같은 비동기 방식으로 동작하는 코드가 없다.

<div className="blog-post">

```ts
function pure(a: number, b: number): number {
  return a + b;
}

function forcePure(array: readonly number[]) {
  array.push(1); // readonly number[] 형식에 push 속성이 없습니다.
}
```

인터페이스, 클래스, 함수의 매개변수등은 const 키워드를 사용하지 못하므로, readonly 타입 수정자를 사용합니다.

</div>

<br />

FP programs often have fewer bugs, and the bugs that do exist are usually in more obvious places, so they're easier to find and fix. In other words, FP pattern is already well proven.

<br />

<h1> Readability </h1>

Fp is one of the most effective tools for crafting readable code.

<br />

<h1> Imperative </h1>

It’s focused on precisely instructing the computer how to do something.
You certainly can trace through its logic to see how the numbers flow and change to the end state, but It’s not at all clear or straightforward.

<br />

<h1> Declarative </h1>

FP is code that’s more focused on describing the what outcome.
The focus shifts from low-level how to higher level what outcomes.

<br />

<h1> Function </h1>

**In math, a function always takes input(s), and always gives an output.** That
means you should be using functions as mums as possible, and trying to avoid procedures
wherever possible.

<br />

**Arguments**

The values you pass in

<hr />

**Parameters**

The named variables inside the function that receive those passed-in values

As of ES6, default parameters can lead to more complexity in terms of reading and understanding

<br />

<h1>Arity</h1>

The number of arguments a function determined by number of parameters

<br />

<h1>Spread operator</h1>

**... operator** is more readable, beacuse the destructing hides the unnecessary details of how to manage the parameter inputs

<br />

<h1>Function multiple outputs</h1>

To consider if a function needing multiple outputs could be refactored to avoid that.
Go for more smaller single-purpose functions

We'll want to prefer pure functions and avoid side effects wherever possible

<br />

<h1>Higher-order function</h1>

JS Functions can receive and return values of any type including functions.

<div className="blog-post">

```js
function forEach(list, fn) {
  for (let v of list) {
    fn(v);
  }
}

forEach([1, 2, 3, 4, 5], function each(val) {
  console.log(val);
});

function foo() {
  return function inner(msg) {
    return msg.toUpperCase();
  };
}

function bar(func) {
  return func("Hello!");
}

let f = foo();
f("Hello!");
foo();
```

</div>

<br />

<h1>Closure</h1>

How a function behaves when it's inside antoher function's scope -
when the inner function makes reference to a variable from the outer function, and
this is **closure**

> scope chain , lexical environment

<div className="blog-post">

```js
function makeAdder(x) {
  return function sum(y) {
    return x + y;
  };
}

let addTo10 = makeAdder(10);
let addTo37 = makeAdder(37);

addTo10(3); // 13
addTo37(13); // 50
```

</div>

<br />

<h1>Named Function > Anonymous Function</h1>
Naming function tends to make code more self-explantory and thus easier to read and
debugging.

if you can't written proper name for some function then you don't fully understand your function's purpose yet -- or it's just too broad or abstract. You need to go back and re-design the function until this is more clear.
if i don't have a good name to use for a function, name it **TODO** initially. and later fix it.

<br />

<h1>Function without function</h1>

<div className="blog-post">

```js
people.map(function getPreferredName(person) {
  return person.nicknames[0] || person.firstName;
});

// vs

people.map((person) => person.nicknames[0] || person.firstName);
```

</div>

Arrow functions are lexically anonymous If person. nicknames isn't defined for some reason, an exception will be thrown, meaning this (anonymous function) will be at the top of the stack trace.
but arrow functions is useful in quick code explorations.
Up to you.

<br />

# Managing Function Inputs

We only want the function to receive a single argument
make helper function

<div className="blog-post">

```js
function identity(v) {
  return v;
}

let words = "   Now is the time for all... ".split(/\s|\b/);
words; // ["","Now","is","the","time","for","all","...",""]
words.filter(identity); // ["Now","is","the","time","for","all","..."]
```

</div>

</div>
