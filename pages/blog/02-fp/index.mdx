import Post from "../../../components/post";

export const meta = {
  title: "Functional Programming",
  description: "함수형 프로그래밍",
  date: "2021-04-16T14:45:00.0Z",
  readTime: 4,
};

export default ({ children }) => <Post meta={meta}>{children}</Post>;

<div style={{ textAlign: "center", fontFamily: "Rajdhani" }}>
  Functional-Light-JS - Kyle Simpson
</div>

<div style={{ marginTop: "4rem", fontFamily: "AppleGothic", fontSize: '11pt', lineHeight: '22pt', letterSpacing: '.8px'}}>

<br />

FP programs often have fewer bugs, and the bugs that do exist are usually in more obvious places, so they're easier to find and fix. In other words, FP pattern is already well proven.

<br />

<h1> Readability </h1>

Fp is one of the most effective tools for crafting readable code.

<br />

<h1> Imperative </h1>

It’s focused on precisely instructing the computer how to do something.
You certainly can trace through its logic to see how the numbers flow and change to the end state, but It’s not at all clear or straightforward.

<br />

<h1> Declarative </h1>

FP is code that’s more focused on describing the what outcome.
The focus shifts from low-level how to higher level what outcomes.

<br />

<h1> Function </h1>

**In math, a function always takes input(s), and always gives an output.** That
means you should be using functions as mums as possible, and trying to avoid procedures
wherever possible.

<br />

**Arguments**

The values you pass in

<hr />

**Parameters**

The named variables inside the function that receive those passed-in values

As of ES6, default parameters can lead to more complexity in terms of reading and understanding

<br />

<h1>Arity</h1>

The number of arguments a function determined by number of parameters

<br />

<h1>Spread operator</h1>

**... operator** is more readable, beacuse the destructing hides the unnecessary details of how to manage the parameter inputs

<br />

<h1>Function multiple outputs</h1>

To consider if a function needing multiple outputs could be refactored to avoid that.
Go for more smaller single-purpose functions

We'll want to prefer pure functions and avoid side effects wherever possible

<br />

<h1>Higher-order function</h1>

JS Functions can receive and return values of any type including functions.

<div className="blog-post">

```js
function forEach(list, fn) {
  for (let v of list) {
    fn(v);
  }
}

forEach([1, 2, 3, 4, 5], function each(val) {
  console.log(val);
});

function foo() {
  return function inner(msg) {
    return msg.toUpperCase();
  };
}

function bar(func) {
  return func("Hello!");
}

let f = foo();
f("Hello!");
foo();
```

</div>

<br />

<h1>Closure</h1>

How a function behaves when it's inside antoher function's scope -
when the inner function makes reference to a variable from the outer function, and
this is **closure**

> scope chain , lexical environment

<div className="blog-post">

```js
function makeAdder(x) {
  return function sum(y) {
    return x + y;
  };
}

let addTo10 = makeAdder(10);
let addTo37 = makeAdder(37);

addTo10(3); // 13
addTo37(13); // 50
```

</div>

<br />

<h1>Named Function > Anonymous Function</h1>
Naming function tends to make code more self-explantory and thus easier to read and
debugging.

if you can't written proper name for some function then you don't fully understand your function's purpose yet -- or it's just too broad or abstract. You need to go back and re-design the function until this is more clear
if i don't have a good name to use for a function, name it **TODO** initially. and later fix it.

<br />

<h1>Function without function</h1>

<div className="blog-post">

```js
people.map(function getPreferredName(person) {
  return person.nicknames[0] || person.firstName;
});

// vs

people.map((person) => person.nicknames[0] || person.firstName);
```

Arrow functions are lexically anonymous

</div>

</div>
